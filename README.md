# ESP-IntelHex-Parser
 This library provides the needed functions to parse a file in Intel HEX format.

> [!NOTE]
> this class currently does not validate the CRC checksum part of the records in the HEX file, since this is not needed directly for the intended use case.
 
 Initially intended to be used to parse Intel Hex files generated by Arduino IDE when compiling an Arduino Firmware.
 
 This initial use case for this library was to extract the pure data needed for flashing an arduino firmware using the STK500 protocol via serial (UART) in pages of defined size (default = 128). 
 
 For mor details of this use case see: [https://github.com/pkerspe/ESP-UARTArduinoFirmwareUpdate](https://github.com/pkerspe/ESP-UARTArduinoFirmwareUpdate)
  
 For additional Information on the Intel HEX Foramte see also: [https://en.wikipedia.org/wiki/Intel_HEX](https://en.wikipedia.org/wiki/Intel_HEX)
  
 ## About the Intel HEX format:
 A Intel HEX files contains multiple lines (records), each following the structure:

 ```<start character ":"><byte count><address><record type><data><checksum>```
 
 **Example:**
 
 the following record
 ```:0300300002337A1E```
 
 decodes to:
 ```
  ------------------------------------------------------------------------------
 | :   |    03    |   0030  |    00       |        02 33 7A        |   1E       |
 |start|byte count| address | record type |      data section      |checksum    |
 |     |  8 bit   | 16 bit  |   0 = dat   |3 bytes 0x02, 0x33, 0x7A|            |
 | b0  |  bit 1-2 | bit 3-6 | bit 7-8     | bit 9-14               | last 2 bits|
  ------------------------------------------------------------------------------
 ```

**Byte count:** two hex digits (one hex digit pair), indicating the number of bytes (hex digit pairs) in the data field.
 The maximum byte count is 255 (0xFF). 8 (0x08),[6] 16 (0x10)[6] and 32 (0x20) are commonly used byte counts.
 In case of the generated HEX files from Arduino, 16 bytes per record are used
 
**Address:** 
 Four hex digits, representing the 16-bit beginning memory address offset of the data.
 The physical address of the data is computed by adding this offset to a previously established base address,
 thus allowing memory addressing beyond the 64 kilobyte limit of 16-bit addresses.
 The base address, which defaults to zero, can be changed by various types of records.
 Base addresses and address offsets are always expressed as big endian values.
 Currently we do not use this address information and rather calculate address in the flashing process itself
 
**Record Types:** (_only relevant types for firmware update process when flashing an Arduino via Serial are listed_)
    00	Data
    01	End Of File		Must occur exactly once per file in the last record of the file. The byte count is 00, the address field is typically 0000 and the data field is omitted.

**Data:** 
 A sequence of n bytes of data, represented by 2n hex digits.
 Some records omit this field (n equals zero). The meaning and interpretation of data bytes depends on the application.
 (4-bit data will either have to be stored in the lower or upper half of the bytes, that is, one byte holds only one addressable data item)

**Checksum** (_ignored in this implementation_): two hex digits, a computed value that can be used to verify the record has no errors.

## Usage examples

The Intel Hex parser currently supports reading content from a File instance (e.g. a file stored in the SPIFFS of the ESP32), in the constructor provide a File instance to a file in SPIFFS 
> [!NOTE]
> make sure the read pointer in the file is a the beginning, so do not perform prior read operations on the file before calling the constructor of the IntelHexParser)

> [!NOTE]
> Make sure to properly initialize SPIFFS before calling the parse function in the library with a file path in SPIFFS!


Example Code for reading single records (=lines) from a HEX file with the name "MyArduinoFirmware.hex" residing in the root folder of the SPIFFS:
```
#include <SPIFFS.h>
#include <IntelHexParser.h>

String filePathInSpiffs = "/MyArduinoFirmware.hex";

void setup() {
    Serial.begin(115200);
    
    // Initialize SPIFFS
    if (!SPIFFS.begin(true))
    {
        Serial.println("SPIFFS Mount Failed");
        return;
    }

    // check if file exists in SPIFFS
    if (!SPIFFS.exists(filePathInSpiffs))
        Serial.printf("File not found in SPIFFS: %s\n", filePathInSpiffs.c_str());
        return;
    }

    // open file for reading
    File file = SPIFFS.open(filePathInSpiffs, "r");
    if (!file)
    {
        Serial.println("Failed opening file for reading");
        return;
    }

    // this is the relevant part for using this library
    IntelHexParser hexParser(fileToFlash);
    // create buffer to store the data (this must be at least as long as the expected data per record in the Intel HEX file (e.g. 16 bytes, weu just use 20 to be save here))
    byte recordDataBufferSize = 20;
    buffer recordDataBuffer[recordDataBufferSize];
    
    // get a parsed record as struct with the needed details and fill the buffer with the actual data:
    // NOTE: you can call getNextRecordToWrite in a loop as long as recordDetails.endOfFileReached == false
    // in this example we only parse the first line in the HEX file
    _recordDetailsStruct recordDetails = hexParser.getNextRecordToWrite(recordDataBuffer, recordDataBufferSize);

    // at this point you can check the error code to see if an error occurred (should be 0 in case of no error) otherwise the buffer should now contain the data from this record (= a line in the hex file)
    if(recordDetails.errorCode == 0){
        Serial.printf("Parsed record in HEX file: address = %i, number of data bytes = %i, end of file reached = %i\n", recordDetails.address, recordDetails.dataLength, recordDetails.endOfFileReached );
    }

    // once you are done, close the file instance
    file.close();
}
```

Example Code for reading a whole page (e.g. 128 bytes) from a HEX file with the name "MyArduinoFirmware.hex" residing in the root folder of the SPIFFS (in this example all the safety checks are omitted to keep the code short, see above for details):
```
#include <SPIFFS.h>
#include <IntelHexParser.h>

String filePathInSpiffs = "/MyArduinoFirmware.hex";

void setup() {
    Serial.begin(115200);
    SPIFFS.begin(true);
    File file = SPIFFS.open(filePathInSpiffs, "r");

    byte pageBufferSize = 128;
    IntelHexParser hexParser(fileToFlash, pageBufferSize);
    buffer pageBuffer[pageBufferSize];
    while(hexParser.getNextPage(pageBuffer)){
        // now do whatever you want with the extracted page data stored in the buffer
    }

    file.close();
}
```