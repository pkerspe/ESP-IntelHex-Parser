#ifndef IntelHexParser_H
#define IntelHexParser_H

#include <Arduino.h>
#include <FS.h>

#define INTEL_HEX_PARSER_RECORD_TYPE_DATA 0
#define INTEL_HEX_PARSER_RECORD_TYPE_END_OF_FILE 1

#define INTEL_HEX_PARSER_BYTE_COUNT_START_INDEX 1
#define INTEL_HEX_PARSER_ADDRESS_START_INDEX 3
#define INTEL_HEX_PARSER_RECORD_TYPE_START_INDEX 7
#define INTEL_HEX_PARSER_DATA_START_INDEX 9

struct _recordDetailsStruct {
	u_int16_t address;
	u_int8_t dataLength;
	bool endOfFileReached = false;
	byte errorCode = 0;
};

/**
 * A class to parse Intel HEX files (stored in some local filesystem). Intended use is to parse Intel Hex files generated by Arduino IDE when compiling an Arduino Firmware.
 * This class is used to extract the pure data needed for flashing a firmware via STK500 protocol in pages of defined size (default = 128).
 * Note: this class ignores the address part and CRC checksum part of the records in the HEX file, since this is not needed directly for the intended use case.
 *
 * See also https://en.wikipedia.org/wiki/Intel_HEX for record format details
 *
 * A hex files contains multiple lines (records), each following the structure:
 * <start character ":"><byte count><address><record type><data><checksum>
 * Example: the following record
 * :0300300002337A1E
 * decodes to:
 *  ------------------------------------------------------------------------------
 * | :   |    03    |   0030  |    00       |        02 33 7A        |   1E       |
 * |start|byte count| address | record type |      data section      |checksum    |
 * |     |  8 bit   | 16 bit  |   0 = dat   |3 bytes 0x02, 0x33, 0x7A|            |
 * | b0  |  bit 1-2 | bit 3-6 | bit 7-8     | bit 9-14				 | last 2 bits|
 *  ------------------------------------------------------------------------------
 *
 * Byte count: two hex digits (one hex digit pair), indicating the number of bytes (hex digit pairs) in the data field.
 * The maximum byte count is 255 (0xFF). 8 (0x08),[6] 16 (0x10)[6] and 32 (0x20) are commonly used byte counts.
 * In case of the generated HEX files from Arduino, 16 bytes per record are used
 *
 * Address (ignored in this implementation): four hex digits, representing the 16-bit beginning memory address offset of the data.
 * The physical address of the data is computed by adding this offset to a previously established base address,
 * thus allowing memory addressing beyond the 64 kilobyte limit of 16-bit addresses.
 * The base address, which defaults to zero, can be changed by various types of records.
 * Base addresses and address offsets are always expressed as big endian values.
 * Currently we do not use this address information and rather calculate address in the flashing process itself
 *
 * Record Types: (relevant for firmware update process):
 * 00	Data
 * 01	End Of File		Must occur exactly once per file in the last record of the file. The byte count is 00, the address field is typically 0000 and the data field is omitted.
 *
 * Data: a sequence of n bytes of data, represented by 2n hex digits.
 * Some records omit this field (n equals zero). The meaning and interpretation of data bytes depends on the application.
 * (4-bit data will either have to be stored in the lower or upper half of the bytes, that is, one byte holds only one addressable data item.
 *
 * Checksum (ignored in this implementation): two hex digits, a computed value that can be used to verify the record has no errors.
 */
class IntelHexParser
{
public:
	/**
	 * Constructor for the IntelHexParser
	 * @param hexFileToParse a File instance reference (open has been called already on this instance but read pointer is still at beginning of file) to the HEX file to be parsed
	 * @param pageSize the page size in bytes to be returned when calling getNextPage. For most ATMEGA models 128 is the correct size.
	 */
	IntelHexParser(File *hexFileToParse, byte pageSize = 128);

	/**
	 * populate the given byte[] with the data for a page (buffer must have same length (or more) as parameter pageSize provided in constructor)
	 * @param pageBuffer the buffer to fill with the page data read from the HEX file
	 * @return boolean true if more page data is available for reading, false if this was the last page from the HEX file
	 */
	bool getNextPage(byte *pageBuffer);

	_recordDetailsStruct getNextRecordToWrite(byte *recordDataBuffer, byte bufferLength);

private:
	/**
	 * get the length of the data section for the given record
	 * return length value indicating number of data bytes in the record
	 */
	int getRecordLength(byte *record);

	/**
	 * determine the type of the record.
	 * Expected values are "0" for a Data record or "1" for the End of file record
	 */
	int getRecordType(byte *record);

	uint16_t getRecordAddress(byte *record);

	/**
	 * extract specified (by len parameter) amount of characters of the data section from the record string and store it in the provided dataBuffer
	 * @param record ref to byte array holding the record (line) from the HEX file to parse
	 * @param len amount of HEX characters to be extracted from the record
	 * @param dataBuffer the byte buffer where to store the data after conversion from HEX to bytes (integer)
	 */
	void extractData(byte *record, int len, byte *dataBuffer);

	File *_hexFileToParse;
	uint8_t _pageSize = 128;
	byte _overflowBuffer[128]; // should always be gte to pageSize
	byte _overflowBufferIndex = 0;
	bool _parsedCompletely = false;
	u_int16_t _recordsParsedCounter = 0;
};

#endif